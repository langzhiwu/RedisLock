# rdslock
用Redis实现分布式锁 与 实现任务队列

一、分布式锁的作用：

    redis写入时不带锁定功能，为防止多个进程同时进行一个操作，出现意想不到的结果，so...对缓存进行插入更新操作时自定义加锁功能。

二、Redis的NX后缀命令

　　Redis有一系列的命令，其特点是以NX结尾，NX的意思可以理解为 NOT EXISTS（不存在），SETNX命令 （SET IF NOT EXISTS） 可以理解为如果不存在则插入，Redis分布式锁的实现主要就是使用SETNX命令。

三、实现原理

   在进程请求执行操作前进行判断，加锁是否成功，加锁成功允许执行下步操作；
   如果不成功，则判断锁的值（时间戳）是否大于当前时间，如果大于当前时间，则获取锁失败不允许执行下步操作；
   如果锁的值（时间戳）小于当前时间，并且GETSET命令获取到的锁的旧值依然小于当前时间，则获取锁成功允许执行下步操作；
   如果锁的值（时间戳）小于当前时间，并且GETSET命令获取到的锁的旧值大于当前时间，则获取锁失败不允许执行下步操作；
    
四、解决死锁

　　如果只用SETNX命令设置锁的话，如果当持有锁的进程崩溃或删除锁失败时，其他进程将无法获取到锁，问题就大了。
    解决方法是在获取锁失败的同时获取锁的值，并将值与当前时间进行对比，如果值小于当前时间说明锁以过期失效，进程可运用Redis的DEL命令删除该锁。但是，简单粗暴的用DEL命令删除锁再SETNX命令上锁也会出现问题。比如，进程1获得锁后崩溃或删除锁失败，这时进程2检测到锁存在当已过期，用DEL命令删除锁并用SETNX命令设置锁，进程3也检测到锁过期，也用DEL命令删除锁也用SETNX命令设置了锁，这时进程2和进程3同时获得了锁。问题大了！

　　为了解决这个问题，这里用到了Redis的GETSET命令，GETSET命令在给锁设置新值的同时返回锁的旧值，这里利用了GETSET命令同时获取和赋值的特性，在此期间其他进程无法修改锁的值。

　　例如：
　　　　进程1获得锁后操作超时/崩溃/删除锁失败，
　　　　进程2检测到锁已存在，但获取锁的值对比当前时间发现锁已过期，
　　　　进程2通过GETSET命令重新给锁赋予新的值，并获取到的锁的旧值，再次对比锁的旧值与当前时间，如果锁的旧值依然小于当前时间的话，这时进程2就可以忽略进程1余留下的废锁进行下步操作了。
　　　　进程2完成下步操作后返回前应该删除锁，但在删除锁时可以先检测锁是否还未过期，未过期才做删除操作，已过期的就没必要在去删除锁了，因为很有可能其他进程检测到锁过期时已经去获取锁了。
